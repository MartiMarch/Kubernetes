# Habilita la interfaz enp0s3 ycrear Adaptador puente --
# Ves a la configuración de la máquina virtual, subapartado “Red” y selecciona la opción “Adaptador puente”.
# vi /etc/sysconfig/network-scripts/ifcfg-enp0s3
# Modifica la opción de “ONBOOT=no” a “ONBOOT=yes” y guarda los cambios.
# service network restart
# ----

# -- Instalación de SSH --
# yum –y install openssh-server openssh-clients
# systemctl start sshd
# systemctl enable sshd
# ----

# -- Instlación de Ansible --
# yum -y install epel-release
# yum -y install ansible
# yum -y update
# ----

# -- Generación de una clave SSH que punta al mismo ordenador --
# ssh-keygen
# Pulsa enter y introduce una frase.
# ssh-copy-id root@{ip}
# vi /etc/ansible/hosts
# Añade la IP del ordenador al que quieres apuntar
# mkdir Ansible
# ----

# -- Comando para instalar el playbook --
# ansible-playbook entorno.yaml --extra-vars "ip="
# ----

# Instalación de un entorno con las siguientes herramientas:
#
#  git
#  JDK 16
#  Docker
#  Docker Compose
#  Helm
#  Kubernetes
#  Nexus 3
---
- name: Iniciando el entorno
  hosts: entorno
  tasks:

  - name: Instalacion de Git
    yum:
      name: git
      state: present

  - name: Se crea una carpeta para las descargas
    ansible.builtin.file:
      path: /descargas
      state: directory

  - name: Instalando Wget
    yum:
      name: wget
      state: present

  - name: Instalando Java 11
    yum:
      name: java-11-openjdk-devel
      state: present

  - name: Instalando Curl
    yum:
      name: curl
      state: present

  - name: Instalando Docker
    yum:
      name: docker
      state: present

  - name: Descargando Docker-Compose
    shell: curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

  - name: Añadiendo los permisos a Docker-Compose
    shell: chmod +x /usr/local/bin/docker-compose

  - name: Iniciando servicio de Docker
    shell: systemctl start docker

  - name: Habilitando el servicio de arranque de Docker
    shell: systemctl enable docker

  - name: Instalando httpd
    yum:
      name: httpd
      state: present

  - name: Iniciando el servicio httpd
    ansible.builtin.systemd:
      name: httpd
      state: started
      enabled: yes

  - name: Creando carpeta para Kubernetes
    ansible.builtin.file:
      path: /kubernetes
      state: directory

  - name: Configurandio el repositorio de Kubernetes
    shell: |
      cat <<EOF > /etc/yum.repos.d/kubernetes.repo
      [kubernetes]
      name=Kubernetes
      baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
      enabled=1
      gpgcheck=1
      repo_gpgcheck=1
      gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
      EOF

  - name: Instalando kubelet
    yum:
      name: kubelet-1.20.0-0
      state: present

  - name: Instalando kubeadm
    yum:
      name: kubeadm-1.20.0-0
      state: present

  - name: Instalando kubectl
    yum:
      name: kubectl-1.20.0-0
      state: present

  - name: Iniciando el servicio kubelet y habilitandolo
    ansible.builtin.systemd:
      name: kubelet
      state: started
      enabled: yes

  - name: Configurando la red
    shell: |
      cat <<EOF > /etc/sysctl.d/k8s.conf
      net.bridge.bridge-nf-call-ip6tables = 1
      net.bridge.bridge-nf-call-iptables = 1
      EOF

  - name: Se modifica el kernel
    shell: sysctl --system

  - name: Se desactiva Selinux
    shell: setenforce 0

  - name: Se configura Selinux
    shell: sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

  - name: Se configura fstab
    shell: sed -i '/swap/d' /etc/fstab

  - name: Se desactiva swap
    shell: swapoff -a

  - name: Creando el cluster de kubernetes
    shell: kubeadm init --apiserver-advertise-address={{ ip }} --pod-network-cidr=10.244.0.0/16
    ignore_errors: yes

  - name: Se crea un directorio para el archivo de configuracion de Kubernetes
    ansible.builtin.file:
      path: ~/kube
      state: directory

  - name: Se crea la carpeta del archivo de configuración de Kubernetes
    shell: mkdir -p  ~/.kube

  - name: Se copia el archivo de configuracion a la ruta anterior
    shell: cp -u /etc/kubernetes/admin.conf ~/.kube/config

  - name: Se aplican los cambios de red a Kubernetes
    shell: kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"

  - name: El nodo maestro ahora puede ser un nodo trabajador
    shell: kubectl taint nodes --all node-role.kubernetes.io/master-
    ignore_errors: yes

  - name: Creano carpeta para Helm
    shell: mkdir -p /Helm

  - name: Descargando Helm 3
    shell: curl -fsSL -o /Helm/get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3

  - name: Otorgando permisos al instaldor
    shell: chdir=/Helm chmod 700 get_helm.sh

  - name: Ejecutando el script
    shell: chdir=/Helm ./get_helm.sh

  - name: Creando carpeta para los yml de Kubernetes
    shell: mkdir -p /kubernetes

  - name: Descargando jenkins-deployment.yml
    shell: curl -o /kubernetes/jenkins-deployment.yaml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/jenkins/jenkins-deployment.yaml"

  - name: Descargando jenkins-pv.yml
    shell: curl -o /kubernetes/jenkins-pv.yml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/jenkins/jenkins-pv.yml"

  - name: Descargando jenkins-pvc.yml
    shell: curl -o /kubernetes/jenkins-pvc.yml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/jenkins/jenkins-pvc.yml"

  - name: Descargando jenkins-service.yaml
    shell: curl -o /kubernetes/jenkins-service.yaml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/jenkins/jenkins-service.yaml"

  - name: Descargando la imagen de Jenkins
    shell: curl -o /kubernetes/jenkins-Dockerfile "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/jenkins/jenkins-Dockerfile.dockerfile"

  - name: Instalado la imagen de Docker
    shell: chdir=/kubernetes docker build -t jenkins -f ./jenkins-Dockerfile .

  - name: Creando el nombre de espacios Jenkins
    shell: kubectl create namespace jenkins
    ignore_errors: yes

  - name: Cargando el volumen persistente de Jenkins
    shell: chdir=/kubernetes kubectl -n jenkins apply -f jenkins-pv.yml

  - name: Cargando la reclamación de volumen persistente de Jenkins
    shell: chdir=/kubernetes kubectl -n jenkins apply -f jenkins-pvc.yml

  - name: Cargando el serivio de red de Jenkins
    shell: chdir=/kubernetes kubectl -n jenkins apply -f jenkins-service.yaml

  - name: Cargando el Deployment de Jenkins
    shell: chdir=/kubernetes kubectl -n jenkins apply -f jenkins-deployment.yaml

  - name: Descargando la imagen de nexus3
    shell: chdir=/kubernetes curl -o ./nexus-Dockerfile "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/nexu3/nexus-Dockerfile.dockerfile"

  - name: Descargando el volumen persistente de nexus 3
    shell: chdir=/kubernetes curl -o ./nexus3-pv.yml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/nexu3/nexus3-pv.yml"

  - name: Descargando la reclamacion de volumen persistente de nexus 3
    shell: chdir=/kubernetes curl -o ./nexus3-pvc.yml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/nexu3/nexus3-pvc.yml"

  - name: Descargando el servicio de nexus 3
    shell: chdir=/kubernetes curl -o ./nexus3-service.yaml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/nexu3/nexus3-service.yaml"

  - name: Descargando el deployment de nexus 3
    shell: chdir=/kubernetes curl -o ./nexus3-deployment.yaml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/nexu3/nexus3-deployment.yaml"

  - name: Creando el nombre de espacios para nexus3
    shell: kubectl create namespace nexus3
    ignore_errors: yes

  - name: Cargando el volumen persistente de Nexus 3
    shell: chdir=/kubernetes kubectl -n nexus3 apply -f nexus3-pv.yml

  - name: Cargando la reclamación de volumen persistente de Nexus 3
    shell: chdir=/kubernetes kubectl -n nexus3 apply -f nexus3-pvc.yml

  - name: Cargando el serivio de red de Nexus 3
    shell: chdir=/kubernetes kubectl -n nexus3 apply -f nexus3-service.yaml

  - name: Cargando el Deployment de Nexus 3
    shell: chdir=/kubernetes kubectl -n nexus3 apply -f nexus3-deployment.yaml

  - name: Creando el nombre de espacios para SonarQube
    shell: kubectl create namespace sonar
    ignore_errors: yes

  - name: Descargando la imagen de SonarQube
    shell: chdir=/kubernetes curl -o ./sonar-Dockerfile "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/sonar/sonar-Dockerfile.dockerfile"

  - name: Instalando la imagen de Sonar
    shell: chdir=/kubernetes docker build -t jenkins -f ./jenkins-Dockerfile .

  - name: Descargando el volumen persistente deSonarQube
    shell: chdir=/kubernetes curl -o ./sonar-pv.yml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/sonar/sonar-pv.yml"

  - name: Descargando la reclamacion de volumen persistente
    shell: chdir=/kubernetes curl -o ./sonar-pvc.yml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/sonar/sonar-pvc.yml"

  - name: Descargando el servicio de SonarQube
    shell: chdir=/kubernetes curl -o ./sonar-service.yaml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/sonar/sonar-service.yaml"

  - name: Descargando el deployment de SonarQube
    shell: chdir=/kubernetes curl -o ./sonar-deployment.yaml "https://raw.githubusercontent.com/MartiMarch/Kubernetes/main/sonar/sonar-deployment.yaml"

  - name: Cargando el volumen persistente de SonarQube
    shell: chdir=/kubernetes kubectl -n sonar apply -f sonar-pv.yml

  - name: Cargando la reclamacion de volumen persistente de SonarQube
    shell: chdir=/kubernetes kubectl -n sonar apply -f sonar-pvc.yml

  - name: Cargando el servicio de SonarQube
    shell: chdir=/kubernetes kubectl -n sonar apply -f sonar-service.yaml

  - name: Cargando el deployment de SonarQube
    shell: chdir=/kubernetes kubectl -n sonar apply -f sonar-deployment.yaml
